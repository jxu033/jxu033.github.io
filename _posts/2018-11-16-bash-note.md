---
title: "Bash Note"
layout: post
date: 2018-11-16 22:44
tag:
- bash
- linux
star: true
category: blog
author: jiaqixu
description: note for bash programming
---

### Table of Content
- [Introduction](#introduction)
- [Variable](#variable)
- [Function](#function)


### Introduction

#### What are Bash Script
剧场和电影的script告诉演员们应该怎么说和怎么做; 一个计算机script告诉计算机应该做什么.
在Bash script的上下文环境中, 它告诉Bash shell应该做什么.

一个BASH脚本就是一个plain text file 包含了一系列的命令. 记住很重要的一点:<br>
Anything you can run normally on the command line can be put into a script and it will do 
exactly the same thing. Similarly, anything you can put into a script can also be run normally on
the command line and it will do exactly the same thing.

我们约定Bash script文件的扩展名为.sh (myscript.sh for example). 我们知道,
Linux是一个extensionless system 因此一个脚本不是必须要以.sh作为扩展名. 换句话说,用任何扩展名,
不会影响他本来的功能.

#### How do they work
这里会说一些背景知识. 了解这些知识会对以后写复杂的脚本很有用.

在Linux的领域(realm)中, 我们有程序和进程的概念. 一个程序是一组二进制数据,由一系列指令组成,这些指令用于CPU和
其他资源(图像,声音文件等),被组织到一个包中,通常存储在硬盘上. 当我们说我们正在运行一个程序时，我们实际上并不是在运行这个程序，
而是它的一个副本，它被称为进程。我们所做的就是将这些指令和资源从硬盘复制到工作内存(或RAM)中。我们还在RAM中为进程分配了一些空间来存储变量(用于保存临时
工作数据)和一些标记，以允许操作系统(OS)在进程执行期间管理和跟踪它.

从本质上讲,进程是程序的运行实例.

可能有多个进程表示同一程序同时在内存中运行。例如，我可以打开两个终端，并在这两个终端中运行命令cp。在这种情况下，系统上有两个cp进程。一旦它们完成了运行，系统就会销毁它们，不再有任何表示程序cp的进程。

When we are at the terminal we have a Bash process running in order to give us the Bash shell. If we start a script running it doesn't actually run in that process but instead starts a new process to run inside.

#### How do we run bash script

值得注意的是:
1. 你可能注意到我们在运行一个bash脚本的时候,会在前面加上<b>./</b>.这是因为当你只在命令行中输入脚本文件名的时候,
Bash只在包含在<b>$PATH</b>这个变量的文件夹路径中尝试寻找这个文件. 所以加上./表示当前路径,因此能去当前文件夹中寻找从而得意执行.
2. The Shebang (#!): 出现在脚本的第一行. (#!)的名称叫做Shebang. 跟随着的是解释器(interpreter)的路径.
3. 你也可以用`Bash script_name.sh`来运行脚本.


### Variable
以下是关于变量使用语法的一些注意点:
1. 加上一个$ sign在变量名前面从而去访问变量.
2. 省去$ sign当设置一个变量的时候.
3. 变量名可以根据个人习惯与喜好设置为任意大写,小写或者混合.
4. 一个变量可以放置在script中的任何位置, 当运行的时候,Bash会用变量值来替代变量. 然后执行命令.

以下是系统给我们设置使用的一些其他变量:
* $0 - Bash 脚本的名字
* $1 ~ $9 - Bash脚本的前9个变量
* $# - 传给Bash脚本的变量的数量
* $@ - 提供给Bash脚本的所有的变量
* $? - 最近运行的进程的exit status
* $$ - 当前脚本的进程ID
* $USER - 运行脚本的用户的名称
* $HOSTNAME - 运行该脚本的机器的主机名
* $SECONDS - 从脚本开始运行到现在的时间(秒数)
* $RANDOM- 返回一个随机数. 在一个脚本中, 每次使用到这个变量返回的值都不同.
* $LINENO - 返回在Bash脚本中当前行的Number

另外可以在命令行上使用命令`env`来查看其他可能会用到的环境变量.

#### Basic form to set a variable
`variable=value` This is one of those areas where formatting is important.<br>
注意到在等号(=)的两边都没有空格; 另外当我们设置变量的时候,其变量名前面是没有$ sign的.

Example:
```bash
#!/bin/bash
# A simple variable example

myvariable=Hello

anothervar=Fred

echo $myvariable $anothervar
echo

sampledir=/etc

ls $sampledir
```

#### Quotes
当我们使用变量去存储更复杂的值的时候,我们需要使用引号. 这是因为在通常情况下,Bash使用空格来判断分开的
items (命令,值).<br>
举个例子, `myvar=Hello Word`就是错误的.会提示`-bash: World: command not found`.

当用引号包含内容的时候,我告诉Bash他们需要被看错是一个item(命令,值), 单引号和双引号是有不同的:
1. 单引号将会把包含的每一个字符当做纯字符.
2. 双引号允许我们做替换,也就是可以包含变量.

Example:
```
user@bash: myvar='Hello Word'
user@bash: echo $myvar
Hello World
user@bash: newvar="More $myvar"
user@bash: echo $newvar
More Hello World
user@bash: newvar='More $myvar'
user@bash: echo $newvar
More $newvar
```

#### Command Substitution
Command substitution允许我们将一个命令或者程序的输出(what would normally be printed to the screen)
作为一个变量的值. 为了实现其, 我们需要将命令放入括号中,并且在前面加上$ sign.

```
user@bash: myvar=$( ls /etc | wc -l)
user@bash: echo There are $myvar entries in the directort /etc.
```

Command substitution is nice and simple if the output of the command is a
 single word or line. If the output goes over several lines then the newlines are simply removed and all the output ends up on a single line.


#### Exporting Variables
变量被限制在他们所在的进程中. 有些时候,一个script可以运行另外一个script作为其命令之一(作为其进程).如果我们
想让变量对第二个脚本可用,我们需要使用export.

当我们export一个变量时,我们告诉Bash每次创建一个新进程的时,都生成一个该变量的拷贝并移交给新建立的进程.因此尽管变量名相同,但是他们
存在不同的进程中,因此彼此无关.

export变量是单向进程.原始进程可以将变量传递给新进程,但是新进程对这个变量的拷贝做的任何操作都对原变量没影响.



### Function

#### Defination
两种不同的定义方法的格式:
```bash
function_name(){
  <commands>
}
```
or
```bash
function function_name{
  <commands>
}
```
值得注意的是:
1. 上面任意一种定义的格式都是合法的. 没有哪种好哪种坏的区别,只是个人喜好与习惯.
2. 在别的编程语言中, 一般参数都会列在参数列表()中. 但在Bash中,这对括号只是为了装饰用的,我们不能放任何东西进去.
3. 方法的定义必须出现在任何调用之前.

Example:
```bash
#! /bin/bash
# Bash function

print_something() {
  echo Hello I am a function
}

print_something
print_something
```

#### Passing Arguments
在Bash Programming中给function传参数类似于给一个script传命令行参数. 我们直接在方法名后面提供参数. 
这些提供的参数可以在方法中被访问通过<b>$1, $2, etc</b>.

Example:
```bash
#! /bin/bash
# Passing arguments to a function

print_something() {
  echo Hello $1
}

print_something Mars
print_something Jupiter
```

#### Return Values
大部分的编程语言中的函数都有返回值(return value)的概念. 但是Bash函数没有这一概念. 但是Bash函数允许
我们设立一个返回状态(return status). 类似于一个程序或者一个command退出并伴随这一个exit status. 这个
exit status表明了这个程序或这个命令执行成功与否. 我们用关键字<b>return</b>来表明一个返回状态(return status).

Example:
```bash
#! /bin/bash
# Setting a return status for a function

print_something() {
  echo Hello $1
  return 5
}

print_something Mars
print_something Jupiter
echo The previous function has a return value of $?
```
1. 在以上代码中, 返回状态不一定要hardcoded. 可以是变量.
2. 记住,变量<b>$?</b>包含了上一个运行的命令或者函数的返回状态,所以在上面代码中,$?是5.
3. 代表性地,返回状态为0表明everything went successfully. 返回状态是一个非0值说明发生了错误.
4. 如果你真的很想返回一个数值(eg. the result of a calculation), 那你可以用返回状态来实现. 
It is not its intended purpose but it will work.

使用Command Substitution,然后用函数打印结果可以解决上述第4点的问题. 
```bash
#! /bin/bash
# Setting a return value to a function

lines_in_file() {
  cat $1 | wc -l
}

num_lines=$( lines_in_file $1 )

echo The file $1 has $num_lines lines in it.
```
在以上代码中:
1. cat $1 | wc -l 将会打印$1所指示的文件的行数.
2. 我们使用command substitution take what would normally be printed to the screen and assign it to the 
variable <b>num_lines</b>














